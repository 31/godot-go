{{ $view := . -}}
package gdnative

/*------------------------------------------------------------------------------
//   This code was generated by template classes.go.tmpl.
//
//   Changes to this file may cause incorrect behavior and will be lost if
//   the code is regenerated. Any updates should be done in
//   "classes.go.tmpl" so they can be included in the generated
//   code.
//----------------------------------------------------------------------------*/

//revive:disable

// #include <godot/gdnative_interface.h>
// #include "gdnative_wrapper.gen.h"
// #include "classes.gen.h"
// #include <stdio.h>
// #include <stdlib.h>
import "C"
import (
	"unsafe"

	"github.com/godot-go/godot-go/pkg/log"
	"go.uber.org/zap"
)

// classes
{{ range $i, $c := $view.Classes -}}
type {{ $c.Name }} struct {
	{{ if $c.Inherits }}
	{{ $c.Inherits }}
	{{ else }}
	wrapped
	{{ end }}
}

{{ if $c.Enums -}}

// section: enums
{{ range $i, $e := $c.Enums -}}
type {{ $c.Name }}{{ $e.GoName }} int
const (
	{{ range $j, $v := $e.Values -}}
	{{ goClassEnumName $c.Name $e.GoName $v.Name }} {{ if eq $j 0 }}{{ $c.Name }}{{ $e.GoName }}{{ end }} = {{ $v.Value }}
	{{ end -}}
)
{{ end }}

{{ end -}}

func NewGDNativeClassFrom{{ $c.Name }}Owner(owner *GodotObject) GDNativeClass {
	inst := &{{ $c.Name }}{}
	inst.Owner = owner

	return (GDNativeClass)(inst)
}

{{ if $c.Methods -}}

// section: methods
func (cx *{{ $c.Name }}) GetClassStatic() TypeName {
	return TypeName("{{ $c.Name }}")
}

func (cx *{{ $c.Name }}) GetParentClassStatic() TypeName {
	return TypeName("{{ $c.Inherits }}")
}

{{ range $j, $m := $c.Methods -}}
{{ $fnReturnType := goReturnType $m.ReturnValue.Type }}
{{ $hasSomeArguments := (or $m.Arguments $m.IsVararg) }}
/* {{ $m.Name }}
 * is_vararg = {{ $m.IsVararg }}, is_static = {{ $m.IsStatic }}
 * ReturnValue = {{ $m.ReturnValue }}
 */
func (cx *{{ $c.Name }}) {{ goMethodName $m.Name }}(
{{range $k, $a := $m.Arguments -}}
{{ goArgumentName $a.Name }} {{ goArgumentType $a.Type }},
{{end -}}
{{- if $m.IsVararg }}varargs ...Variant,{{ end }}
) {{ $fnReturnType }} {
    {{/* TODO: refactor for static instantiation */}}
	cGdiPtr := (*C.GDNativeInterface)(internal.gdnInterface)
    cClassName := C.CString("{{ $c.Name }}")
	cMethodName := C.CString("{{ $m.Name }}")
	cHash := C.long({{ $m.Hash }})
	fn := C.cgo_GDNativeInterface_classdb_get_method_bind(cGdiPtr, cClassName, cMethodName, cHash)
    C.free(unsafe.Pointer(cClassName))
	C.free(unsafe.Pointer(cMethodName))

	if fn == nil {
		panic("could not find method function {{ $c.Name }}.{{ $m.Name }} ({{ $m.Hash }})")
	}

	{{ if $fnReturnType -}}
	var ret {{ $fnReturnType }}
	{{ if $m.IsVararg}}
	retPtr := (C.GDNativeVariantPtr)(unsafe.Pointer(&ret))
	{{ else -}}
	retPtr := (C.GDNativeTypePtr)(unsafe.Pointer(&ret))
	{{ end -}}
	{{- else -}}
	{{ if $m.IsVararg}}
	retPtr := (C.GDNativeVariantPtr)(nullptr)
	{{ else -}}
	retPtr := (C.GDNativeTypePtr)(nullptr)
	{{ end -}}
	{{- end }}

	sz := unsafe.Sizeof(nullptr) * uintptr({{ len $m.Arguments }}{{ if $m.IsVararg }} + len(varargs) + 1{{ end }})

	argBytes := unsafe.Pointer(C.malloc(C.size_t(sz)))

	{{ if $m.IsVararg }}
	argsPtr := (*[{{ len $m.Arguments }}]unsafe.Pointer)(argBytes)

	{{ range $j, $a := $m.Arguments -}}
		argsPtr[{{ $j }}] = unsafe.Pointer(&{{ goArgumentName $a.Name }})
	{{ end }}

    {{ if $m.IsVararg -}}
    for i := range varargs {
        argsPtr[i + {{ len $m.Arguments }}] = unsafe.Pointer(&varargs[i])
    }
    {{ end -}}

	{{ end }}

	cOwner := (C.GDNativeObjectPtr)(unsafe.Pointer(cx.GetGodotObjectOwner()))

	{{ if $m.IsVararg -}}
	var err GDNativeCallError

	C.cgo_GDNativeInterface_object_method_bind_call(cGdiPtr, fn, cOwner, (*C.GDNativeVariantPtr)(unsafe.Pointer(argsPtr)), (C.long)(sz), retPtr, (*C.GDNativeCallError)(&err))

	if !err.Ok() {
		log.Panic("method bind call error", zap.Error(&err))
	}
	{{ else -}}
	cArgs := (*C.GDNativeTypePtr)(argBytes)

	C.cgo_GDNativeInterface_object_method_bind_ptrcall(cGdiPtr, fn, cOwner, cArgs, retPtr)
	{{ end -}}

	{{ with $fnReturnType -}}
	C.free(argBytes)
	return ret
	{{- end }}
}
{{ end -}}

{{ end -}}

{{ if $c.Constants }}
// section: constants
{{ range $j, $m := $c.Constants -}}
// {{ $m.Name }} {{ $m.Type }} {{ $m.Value }}
{{ end -}}
{{ end -}}

//export GoCallback_{{ $c.Name }}_GDNativeBindingCreate
func GoCallback_{{ $c.Name }}_GDNativeBindingCreate(p_token unsafe.Pointer, p_instance unsafe.Pointer) unsafe.Pointer {
	return GoCallback_GDNativeBindingCreate[*{{ $c.Name }}](p_token, p_instance)
}

//export GoCallback_{{ $c.Name }}_GDNativeBindingFree
func GoCallback_{{ $c.Name }}_GDNativeBindingFree(p_token unsafe.Pointer, p_instance unsafe.Pointer, p_binding unsafe.Pointer) {
	GoCallback_GDNativeBindingFree[*{{ $c.Name }}](p_token, p_instance, p_binding)
}

//export GoCallback_{{ $c.Name }}_GDNativeBindingReference
func GoCallback_{{ $c.Name }}_GDNativeBindingReference(p_token unsafe.Pointer, p_instance unsafe.Pointer, p_reference C.GDNativeBool) C.GDNativeBool {
	return (C.GDNativeBool)(GoCallback_GDNativeBindingReference[*{{ $c.Name }}](p_token, p_instance, (GDNativeBool)(p_reference)))
}

{{ end -}}

func init() {
	gdExtensionBindingGDNativeInstanceBindingCallbacks = NewSyncMap[TypeName, GDNativeInstanceBindingCallbacks]() 
{{ range $i, $c := $view.Classes -}}
	gdExtensionBindingGDNativeInstanceBindingCallbacks.Set("{{ $c.Name }}", (GDNativeInstanceBindingCallbacks)(C.___binding_callbacks_{{ $c.Name }}))
{{ end -}}

	gdNativeConstructors = NewSyncMap[TypeName, GDNativeClassGoConstructorFromOwner]()
{{ range $i, $c := $view.Classes -}}
	gdNativeConstructors.Set("{{ $c.Name }}", NewGDNativeClassFrom{{ $c.Name }}Owner)
{{ end -}}
}
